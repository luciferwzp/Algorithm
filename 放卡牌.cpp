//假如有编号为1~3的3张扑克牌和编号为1~3的3个盒子，现在需要将3张牌分别放到3个盒子中去，且每个盒子只能放一张牌，
//一共有多少种不同的放法。

//当走到一个盒子面前的时候，到底要放那一张牌呢？在这里应该把所有的牌都尝试一遍。假设这里约定一个顺序，
//按牌面值从小到大依次尝试。在这样的假定下，当走到第一个盒子的时候，放入1号牌。
//放好之后，继续向后走，走到第二个盒子面前，此时还剩2张牌，牌面值最小的为2号牌，按照约定的规则，把2号牌放入第二个盒子。
//此时，来到第三个盒子面前，只剩一张牌，放入第三个盒子。此时手中的牌已经用完。
//继续向后走，走到了盒子的尽头，后面再也没有盒子，并且也没有可用的牌了，此时，一种放法已经完成了，
//但是这只是一种放法，这条路已经走到了尽头，还需要折返，重新回到上一个盒子。
//这里回到第三个盒子，把第三个盒子中的牌取出来，再去尝试能否再放其它的牌，这时候手里仍然只有一张3号牌，
//没有别的选择了，所以还需要继续向后回退，回到2号盒子面前。
//收回2号盒子中的2号牌，现在手里有两张牌，2，3，按照约定，再把3号牌放入2号盒子，放好之后，继续向后走，来到3号盒子。
//此事手里只有一张2号牌，把它放入3号盒子，继续向后走。
//此时这条路又一次走到了尽头，一个新的放法又产生了，继续向上折返，尝试其它可能，按照上述步骤，依次会产生所有结果。


#include <vector>
#include <iostream>
using namespace std;
void Dfs(int index, int n, vector<int>& boxs, vector<int>& book) {
    if (index == n + 1)
    {
        for (int i = 1; i <= n; i++)
            cout << boxs[i] << " ";
        cout << endl;
        return; //向上回退    
    }
    for (int i = 1; i <= n; i++)
    {
        if (book[i] == 0)  //第i号牌仍在手上
        {
            boxs[index] = i;
            book[i] = 1;  //现在第i号牌已经被用了
                //处理下一个盒子
                Dfs(index + 1, n, boxs, book);
                //从下一个盒子回退到当前盒子，取出当前盒子的牌，
                //尝试放入其它牌。
                book[i] = 0; 
        }
    }
}
int main()
{
    int n;
    vector<int> boxs;
    vector<int> books;
    cin >> n;
    boxs.resize(n + 1, 0);
    books.resize(n + 1, 0);
    Dfs(1, n, boxs, books);
    return 0; 
}
